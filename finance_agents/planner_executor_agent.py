from agents import Agent, Runner, function_tool

from datetime import date
from dataclasses import dataclass
from typing import Literal

from finance_agents.company_overview_agent import company_overview_agent
from finance_agents.trend_analysis_agent import trend_analysis_agent
from finance_agents.top_companies_list_agent import top_company_ranked_agent

from finance_agents.input_guardrails import idx_only_query_guardrail, compliance_guardrail

from schemas.finance_app import GeneralizedOutput, PlannerOutput

# Define agent as a tool to get company overview
@function_tool
async def get_company_overview(ticker: str) -> str:
    """
    A tool to retrieve company overview.

    Args:
        ticker (str): The stock ticker of the company.
    """

    agent = company_overview_agent
    result = await Runner.run(
        agent,
        f"Provide a summary overview for the company with ticker {ticker}."
    )
    return result.final_output

# Define agent as a tool to get daily transaction analysis
@function_tool
async def get_company_daily_transaction(ticker: str, metrics: str, date_period: str) -> str:
    """
    A tool to run trend analysis on daily transaction for a company.

    Args:
        ticker (str): The stock ticker of the company.
        metrics (str): The metrics to analyze, such as "volume" or "price".
        date_period (str): The date range for the analysis as in the user query.
    """

    agent = trend_analysis_agent
    result = await Runner.run(
        agent,
        f"Analyze {metrics} for {ticker} in the time period {date_period}."
    )
    return result.final_output

# Define agent as a tool to get top companies ranked by market cap
@function_tool
async def get_top_companies_ranked(
    n: int,
    sort_by: str,
    year: int
) -> str:
    """
    A tool to retrieve top companies ranked by 
        - Dividend yield
        - Earnings
        - Market cap
        - Revenue
        - Total dividend
        - PB / PE / PS ratios
    Args:
        n (int): The number of top companies to retrieve.
        sort_by: The criteria to sort the companies.
    """

    agent = top_company_ranked_agent
    result = await Runner.run(
        agent,
        f"Provide a list of the top {n} companies ranked by {sort_by} in year {year}."
    )
    return result.final_output

# Define the planner agent to break down user queries into actionable steps
planner_instructions = (
    "Given a user query, decompose it into a sequence of tool invocations."
    "For each step, specify the tool name and required parameters. "
    "Only use the available tools: get_company_overview, get_company_daily_transaction, get_top_companies_ranked." \
    "Do NOT call or execute the tools here, only output the plan steps.   " \
    "Example input: 'Show me the top 3 companies by market cap in 2024 and provide a summary overview for each company." \
    "Example output: " \
    "Step 1: Call get_top_companies_ranked to return top 3 companies by market cap in 2024" \
    "Step 2: For each company ticker returned in Step 1, call get_company_overview with tickers from step 1." \
    "Step 3: Combine the summaries from Step 2 into a final report."  
)

planner_agent = Agent(
    name="Planner Agent",
    instructions=planner_instructions,
    input_guardrails=[
        idx_only_query_guardrail,
        compliance_guardrail
    ],
    output_type=PlannerOutput,
    tools=[
        get_company_overview,
        get_company_daily_transaction,
        get_top_companies_ranked
    ]   
)

async def run_planner_agent(input_promt: str) -> PlannerOutput:
    """
    Run the planner agent to decompose user queries into actionable steps.

    Args:
        input_promt (str): The user query to process.
    
    Returns:
        PlannerOutput: The output containing the steps to execute.
    """
    result = await Runner.run(
        planner_agent,
        input_promt
    )
    return result.final_output

# Define the executor agent to execute the steps generated by the planner agent
executor_instructions = (
    "Your task is to respond user's query from planner agent using the tools provided."
    "Always pass the full user query as input to any tool you invoke. "
    "You must rely exclusively on the available tools to answer the query â€” do not generate responses independently. "
    f"The current date is {date.today()}. "
    "All responses must strictly follow the GeneralizedOutput schema. Do not generate or return images for charts or visualizations. "
    "If multiple tools are used, provide a clear and concise summary of their combined outputs."
)

executor_agent = Agent(
    name="Executor Agent",
    instructions=executor_instructions,
    tools=[
        get_company_overview,
        get_company_daily_transaction,
        get_top_companies_ranked
    ],
    output_type=GeneralizedOutput
)

async def run_executor_agent(input_promt: PlannerOutput) -> GeneralizedOutput:
    """
    Run the executor agent to execute the steps generated by the planner agent.

    Args:
        input_promt (PlannerOutput): The output from the planner agent containing the steps to execute.
    
    Returns:
        GeneralizedOutput: The final output after executing the steps.
    """
    result = await Runner.run(
        executor_agent,
        input_promt
    )
    return result.final_output


if __name__ == "__main__":
    import asyncio

    from utils.config import setup_openai_api_key, setup_sectors_api_key
    setup_openai_api_key()
    setup_sectors_api_key()

    # Example usage of the planner and executor agents
    query = input("Input query:")
    planner_result = asyncio.run(run_planner_agent(query))
    
    if planner_result.execute_steps:
        print("User query:", planner_result.user_query)
        print("Steps to execute:")
        print(planner_result.steps)
        
        executor_result = asyncio.run(run_planner_agent(planner_result))
        print("Final output after executor agent:", executor_result)
    else:
        print("No steps to execute.")
        print(f"Reason: {planner_result.reason}")
        print("Final output:", planner_result.steps)